1.套接字的阻塞和非阻塞send/recv：
https://blog.csdn.net/shy_hc/article/details/69950334
阻塞就是让当前调用线程一直处于停止等待当中，挂起的状态，线程函数会被卡住。
非阻塞则是不管运行结果如何，都会继续往下执行（往往都要处理很多返回结果），线程函数里一般都是一个循环，不停的轮询。

send/sendto函数，只是把应用层的数据拷贝到内核发送缓冲区，并不保证数据一定会被发送到对端，真正执行发送及什么时候发送是由系统(协议栈)决定的，所以send/sendto函数返回成功，只能说明拷贝成功了，如果在还未发送之前网络断开，则发送失败。

recv/recvform函数,，将内核接收缓冲区的数据拷贝到应用层的buffer中，真正执行接收数据也是由系统层决定的。

套接字默认是阻塞状态，因此发送及接收也是阻塞状态，所以调用不会立即返回，而是进入睡眠等待操作完成。


2.关于内核缓冲区，和应用程序缓冲区:
https://blog.csdn.net/tong_xin2010/article/details/38944587?utm_source=blogkpcl5
应用缓冲技术能很明显的提高系统效率。内核与外围设备的数据交换，内核与用户空间的数据交换都是比较费时的，使用缓冲区就是为了优化这些费时的操作。
其实核心到用户空间的操作本身是不buffer的，是由I/O库用buffer来优化了这个操作。比如read本来从内核读取数据时是比较费时的，所以一次取出一块，
以避免多次陷入内核。
应用内核缓冲区的 主要思想就是一次读入大量的数据放在缓冲区，需要的时候从缓冲区取得数据。
管理员模式和用户模式之间的切换需要消耗时间，但相比之下，磁盘的I/O操作消耗的时间更多，为了提高效率，内核也使用缓冲区技术来提高对磁盘的访问速度。
磁盘是数据块 的集合，内核会对磁盘上的数据块做缓冲。内核将磁盘上的数据块复制到内核缓冲区中，当一个用户空间中的进程要从磁盘上读数据时，
内核一般不直接读磁盘，而 是将内核缓冲区中的数据复制到进程的缓冲区中。当进程所要求的数据块不在内核缓冲区时，内核会把相应的数据块加入到请求队列，
然后把该进程挂起，接着为其 他进程服务。一段时间之后(其实很短的时间)，内核把相应的数据块从磁盘读到内核缓冲区，然后再把数据复制到进程的缓冲区中，
最后唤醒被挂起的进程。

注：理解内核缓冲区技术的原理有助于更好的掌握系统调用read&write，read把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区，它们不等价于数据在内核缓冲区和磁盘之间的交换。
从理论上讲，内核可以在任何时候写磁盘，但并不是所有的write操作都会导致内核的写动作。内核会把要写的数据暂时存在缓冲区中，积累到一定数量后再一 次写入。有时会导致意外情况，比如断电，内核还来不及把内核缓冲区中的数据写道磁盘上，这些更新的数据就会丢失。
应用内核缓冲技术导致的结果是：提高了磁盘的I/O效率；优化了磁盘的写操作；需要及时的将缓冲数据写到磁盘。


